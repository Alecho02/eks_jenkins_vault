// Jenkinsfile - Jenkins en EKS, build+push a ECR, secretos en Vault y deploy a eks-development

podTemplate(
    label: 'ci-agent',
    namespace: 'jenkins',
    serviceAccount: 'jenkins',
    containers: [

        // 1) Build Java
        containerTemplate(
            name: 'maven',
            image: 'maven:3.9-eclipse-temurin-17',
            ttyEnabled: true,
            command: 'cat',
            workingDir: '/home/jenkins/agent'
        ),

        // 2) AWS CLI (ECR + EKS + kubectl)
        containerTemplate(
            name: 'aws',
            image: 'amazon/aws-cli:2.15.36',
            ttyEnabled: true,
            command: 'sh',
            args: '-c cat',
            workingDir: '/home/jenkins/agent'
        ),

        // 3) Docker CLI (habla con el daemon dind)
        containerTemplate(
            name: 'docker',
            image: 'docker:27',
            ttyEnabled: true,
            command: 'sh',
            args: '-c cat',
            workingDir: '/home/jenkins/agent',
            envVars: [
                envVar(key: 'DOCKER_HOST',        value: 'tcp://localhost:2375'),
                envVar(key: 'DOCKER_TLS_CERTDIR', value: '')
            ]
        ),

        // 4) Docker-in-Docker (el daemon)
        containerTemplate(
            name: 'dind',
            image: 'docker:27-dind',
            ttyEnabled: true,
            privileged: true,
            command: 'dockerd-entrypoint.sh',
            args: '--host=tcp://0.0.0.0:2375',
            workingDir: '/home/jenkins/agent',
            envVars: [
                envVar(key: 'DOCKER_TLS_CERTDIR', value: '')
            ]
        )
    ],
    volumes: [
        emptyDirVolume(mountPath: '/var/lib/docker', memory: false)
    ]
) {

    node('ci-agent') {

        // === Constantes de tu entorno ===
        def APP_DIR           = 'prueba_v1c3nt3/app/microservice'
        def AWS_REGION        = 'eu-west-1'
        def ECR_REGISTRY      = '385205418910.dkr.ecr.eu-west-1.amazonaws.com'
        def ECR_REPO          = "${ECR_REGISTRY}/microservice-devops"
        def EKS_CLUSTER       = 'eks-development'
        def K8S_MANIFEST      = 'prueba_v1c3nt3/k8s/development/deployment.yaml'
        def IMAGE_TAG         = "build-${env.BUILD_NUMBER}"
        def FULL_IMAGE        = "${ECR_REPO}:${IMAGE_TAG}"
        def KUBECONFIG_FILE   = "${env.WORKSPACE}/kubeconfig"
        def ECR_PASSWORD_FILE = "${env.WORKSPACE}/ecr_password.txt"

        // =========================
        stage('Checkout') {
            checkout scm
        }

        // =========================
        // 1. Leer secretos desde Vault
        // =========================
        stage('Vault - leer secretos') {
            container('maven') {
                // Credencial de tipo "Secret text" con el token de Vault (root en dev)
                withCredentials([string(credentialsId: 'vault-token', variable: 'VAULT_TOKEN')]) {
                    script {
                        // Llamamos a Vault (http://vault.vault.svc.cluster.local:8200)
                        def salida = sh(
                            script: '''
                                set -e

                                # Instalamos curl y jq si no existen (Debian based)
                                apt-get update >/dev/null 2>&1 || true
                                apt-get install -y curl jq >/dev/null 2>&1 || true

                                VAULT_ADDR="http://vault.vault.svc.cluster.local:8200"

                                echo "Consultando Vault en $VAULT_ADDR ..."
                                JSON=$(curl -s \
                                  -H "X-Vault-Token: $VAULT_TOKEN" \
                                  "$VAULT_ADDR/v1/secret/data/microservice")

                                # Extraemos los campos que definiste en Vault
                                SECRET_VALUE=$(echo "$JSON" | jq -r '.data.data.SECRET_VALUE')
                                CONFIG_VALUE=$(echo "$JSON" | jq -r '.data.data.CONFIG_VALUE')

                                # Devolvemos los dos valores en una sola línea
                                echo "$SECRET_VALUE:::$CONFIG_VALUE"
                            ''',
                            returnStdout: true
                        ).trim()

                        def partes = salida.split(':::')
                        env.SECRET_VALUE = partes[0]
                        env.CONFIG_VALUE = partes[1]

                        // Pequeño check (NO imprimir el secreto real en un caso real)
                        echo "Vault: se obtuvo SECRET_VALUE y CONFIG_VALUE (no se muestran por seguridad)."
                    }
                }
            }
        }

        // =========================
        stage('Build & Test (Maven)') {
            container('maven') {
                dir(APP_DIR) {
                    sh 'mvn -B clean test'
                }
            }
        }

        // =========================
        stage('Package (JAR)') {
            container('maven') {
                dir(APP_DIR) {
                    sh 'mvn -B package -DskipTests'
                }
            }
        }

        // =========================
        stage('Login ECR (AWS CLI)') {
            container('aws') {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-devops',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    sh """
                        set -e
                        aws --version
                        aws sts get-caller-identity
                        aws ecr get-login-password --region ${AWS_REGION} > "${ECR_PASSWORD_FILE}"
                    """
                }
            }
        }

        // =========================
        stage('Build & Push Docker image a ECR') {
            container('docker') {
                sh """
                    set -e
                    echo "Autenticando contra ECR..."
                    PASS=\$(cat "${ECR_PASSWORD_FILE}")
                    echo "\$PASS" | docker login \\
                      --username AWS \\
                      --password-stdin ${ECR_REGISTRY}

                    echo "Build de la imagen: ${FULL_IMAGE}"
                    docker build \\
                      -t ${FULL_IMAGE} \\
                      -f ${APP_DIR}/Dockerfile \\
                      ${APP_DIR}

                    echo "Push de la imagen a ECR..."
                    docker push ${FULL_IMAGE}
                """
            }
        }

        // =========================
        // kubeconfig + Secret/ConfigMap + deploy en eks-development
        // =========================
        stage('Deploy a EKS (dev)') {
            container('aws') {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-devops',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    sh """
                        set -e
                        export AWS_REGION=${AWS_REGION}

                        echo "Actualizando kubeconfig..."
                        aws eks update-kubeconfig \\
                          --name ${EKS_CLUSTER} \\
                          --region ${AWS_REGION} \\
                          --kubeconfig "${KUBECONFIG_FILE}"

                        echo "Instalando kubectl (si no existe)..."
                        if ! command -v kubectl >/dev/null 2>&1; then
                          if command -v curl >/dev/null 2>&1; then
                            curl -L -o kubectl "https://dl.k8s.io/release/v1.30.0/bin/linux/amd64/kubectl"
                          else
                            wget -O kubectl "https://dl.k8s.io/release/v1.30.0/bin/linux/amd64/kubectl"
                          fi
                          chmod +x kubectl
                          mv kubectl /usr/local/bin/kubectl
                        fi

                        echo "Creando/actualizando Secret y ConfigMap con valores de Vault..."
                        kubectl --kubeconfig="${KUBECONFIG_FILE}" -n microservice \\
                          create secret generic microservice-secrets \\
                          --from-literal=SECRET_VALUE="${SECRET_VALUE}" \\
                          --dry-run=client -o yaml | \\
                          kubectl --kubeconfig="${KUBECONFIG_FILE}" -n microservice apply -f -

                        kubectl --kubeconfig="${KUBECONFIG_FILE}" -n microservice \\
                          create configmap microservice-config \\
                          --from-literal=CONFIG_VALUE="${CONFIG_VALUE}" \\
                          --dry-run=client -o yaml | \\
                          kubectl --kubeconfig="${KUBECONFIG_FILE}" -n microservice apply -f -

                        echo "Aplicando manifiesto base (deployment, service, etc.)..."
                        kubectl --kubeconfig="${KUBECONFIG_FILE}" apply -f ${K8S_MANIFEST}

                        echo "Actualizando deployment con la imagen del build..."
                        kubectl --kubeconfig="${KUBECONFIG_FILE}" -n microservice \\
                          set image deployment/microservice-devops \\
                          microservice-devops=${FULL_IMAGE} --record

                        echo "Esperando rollout..."
                        kubectl --kubeconfig="${KUBECONFIG_FILE}" -n microservice \\
                          rollout status deployment/microservice-devops

                        echo "Pods en el namespace microservice:"
                        kubectl --kubeconfig="${KUBECONFIG_FILE}" -n microservice get pods
                    """
                }
            }
        }
    }
}
